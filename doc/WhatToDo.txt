задача:

Разработать на C++ клиент-серверное приложение под Linux,
для подсчета наименьшего общего кратного чисел.
Клиентское приложение получает от пользователя число
и передает данные числа на сервер
и выводит на консоль результат, полученный от сервера.

Сервер получает от клиента число
и вычисляет наибольшее общее кратное между этим числом
и множеством чисел переданными на сервер ранее
и передает клиентскому приложению результат.

При реализации задачи необходимо учесть,
что клиентских приложений может быть несколько.

Критерии оценки выполнения задачи:

* Корректность полученных результатов
* Качество кода
* Оптимальный алгоритм

=============================================================================

план:
  выбор методов и генерация идей
  поиск существующих решений и инструментария
  осмотр-объезжание инструментария
  реализация решателя
  реализация коммуникации (клиента + сервера)
  связывание сервера и решателя
  праздновение победы.

методы и идеи:
  * НОК меж двух чисел это
    а) взять НОД, поделить каждое число на НОД, перемножить результаты с НОД
    б) взять числа, разложить на множества простых множителей (неуникальных).
       НОД будет пересечением множеств,
       НОК будет объединением множества остатков от вычитания множеств с НОД
       со множеством НОД
  * приложение многопользовательское,
    с необходимостью хранить состояние сессии.
    из проблем - чистка и хранение данных сесии
  * если перенести ответственность хранения промежуточных данных на клиенте,
    то можно и без сессий. без сессий проще. и надёжнее.
  * про размеры чисел в задаче не указано
  * НОД(а,б,ц) === НОД(НОД(а,б), ц) == НОД(а,НОД(б, ц))
    => нет нужды хранить все множества, хватит и последнего результата
  * делаем [S]ingle Responsibility - отдельные сущности:
    * решАло
    * выполнЯло
    * служИло
    * вызывАло
    * склиентомговорИло
  * ставить лучше в отдельные доки. так будет проще
    и зависимости будут видны.
  
кандидаты в помощники:
  * GiNaC - во-первых, возможность работы с длинными числами,
            во-вторых, можно не велосипедить с НОД/НОК: там их есть.
            в репах есть.
  * libevent - потому что пользуется у заказчика
               и потому что можно малой кровью смастерить и http-сервер,
               и rpc-сервер, и rpc-клиент.
               в репах есть.
  * 0mq - потому что уже работал с ним.
          и тоже есть в линухе в репозиториях.
  * getopt - потому что надо же обрабатывать argc+argv по-человечески =)
             (а может и не надо и хватит двух аргументов)
  * boost::program_options - тоже кандидат на обработку argc+argv
  * cmake - потому что надо чем-то собирать и как-то искать библиотеки.
  * docker - чтобы не заморачиваться с описанием что куда ставить.
